#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Notes
-----

This script adds writing and reading functions
"""

import os
import time
import numpy as np
import scipy as sp
import zipfile as zf
from rgmol.objects import *
import rgmol


def _get_file_location(file):
    """gets the location of the file of the output of the molecule"""
    file_splitted = file.split("//")[:-1]
    file_location = ""

    for f in file_splitted:
        file_location += f
        file_location +="//"

    return file_location

def _write_vector_for_cube(Lines,vector):
    """Writes a vector in a file"""
    for elem in vector:
        long = len(str(abs(int(elem))))
        Lines.append(" "*(4-long))
        Lines.append("{:9.6f}".format(elem))

def _write_data_for_cube(Lines,vector):
    """Writes a vector in a file"""
    line = ""
    for elem in vector:
        m = int(np.sign(elem)/2-1/2)
        line += " "*(3+m)
        line += "{:9.5e}".format(elem)
    Lines.append(line)

def _write_voxel(file_name,voxel_matrix,voxel_origin,grid_points):
    """Writes the voxel parameters in a file"""

    with open(file_name,"w") as file:
        file.write("Voxel Matrix :\n")
        file.write("{} {} {}\n".format(voxel_matrix[0][0],voxel_matrix[0][1],voxel_matrix[0][2]))
        file.write("{} {} {}\n".format(voxel_matrix[1][0],voxel_matrix[1][1],voxel_matrix[1][2]))
        file.write("{} {} {}\n".format(voxel_matrix[2][0],voxel_matrix[2][1],voxel_matrix[2][2]))
        file.write("Voxel Origin :\n")
        file.write("{} {} {}\n".format(voxel_origin[0],voxel_origin[1],voxel_origin[2]))
        file.write("Grid Points :\n")
        file.write("{} {} {}\n".format(grid_points[0],grid_points[1],grid_points[2]))


def _read_voxel(file_name):
    """Reads the voxel parameters from a file written using the write_voxel function"""

    count = 0
    voxel_matrix=[]
    for line in open(file_name,"r"):
        lsplit = line.split()
        if count > 0 and count < 4:
            voxel_matrix.append([float(lsplit[0]),float(lsplit[1]),float(lsplit[2])])
        elif count == 5:
            voxel_origin = [float(lsplit[0]),float(lsplit[1]),float(lsplit[2])]
        elif count == 7:
            grid_points = [int(lsplit[0]),int(lsplit[1]),int(lsplit[2])]

        count+=1
    return voxel_matrix,voxel_origin,grid_points


def write_cube(self,cube,file_name,description="cube"):
    """
    write_cube(cube,file_name,description="cube")

    Writes a cube file of a 3D vector inside a folder called rgmol which will be located inside the folder containing the molecule.

    Parameters
    ----------
        cube : ndarray
            The 3D vector to be stored in the cube file
        file_name : str
            The name of the file
        description : str
            Description of the file inside the cube file

    Returns
    -------
        None
            The cube file is written
    """
    Lines = []
    Lines.append("Cube data generated by rgmol\n")
    Lines.append(description+"\n")

    #Number atoms and voxel origin
    num_atoms = str(len(self.atoms))
    voxel_origin = self.properties["voxel_origin"]

    Lines.append(" "*(5-len(num_atoms)) +num_atoms)
    _write_vector_for_cube(Lines,voxel_origin)

    Lines.append("\n")

    #Number of points and voxel matrix
    voxel_matrix = self.properties["voxel_matrix"]
    grid_points = self.properties["grid_points"]

    grid_points_0 = str(grid_points[0])
    Lines.append(" "*(5-len(grid_points_0)) + grid_points_0)
    _write_vector_for_cube(Lines,voxel_matrix[0])
    Lines.append("\n")
    grid_points_1 = str(grid_points[1])
    Lines.append(" "*(5-len(grid_points_1)) + grid_points_1)
    _write_vector_for_cube(Lines,voxel_matrix[1])
    Lines.append("\n")
    grid_points_2 = str(grid_points[2])
    Lines.append(" "*(5-len(grid_points_2)) + grid_points_2)
    _write_vector_for_cube(Lines,voxel_matrix[2])
    Lines.append("\n")

    #Write atom positions
    for atom in self.atoms:
        atomic_number = atom.atomic_number
        Lines.append(" "*(5-len(str(atomic_number)))+str(atomic_number))
        Lines.append(" "*(4-len(str(atomic_number)))+"{:9.6f}".format(atomic_number))
        _write_vector_for_cube(Lines,atom.pos)
        Lines.append("\n")

    #Write cube
    for vec_x in cube:
        for vec_y in vec_x:
            line_length = grid_points[2]
            count = 0
            while count < line_length:
                _write_data_for_cube(Lines,vec_y[count:count+6])
                Lines.append('\n')
                count+=6

    with open(file_name,"w") as file:
        file.writelines(Lines)

def write_txt(self,cube,file_name):
    """
    write_txt(cube,file_name)

    This functions writes a txt file containing a 3D array.
    This method is not the preferred one, just use mol.save()

    Parameters
    ----------
        cube : ndarray
            The cube file to save
        file_name : str
            The name of the file

    Returns
    -------
        None
            The file is written
    """

    grid_points = self.properties["grid_points"]
    nx,ny,nz = grid_points
    comments = ""
    for coord in grid_points:
        comments += str(coord) + " "

    np.savetxt(file_name,cube.reshape((nx*ny,nz)),header=comments,fmt="%3.6e")


molecule.write_cube = write_cube
molecule.write_txt = write_txt



#########################################
## Adding save functions for molecules ##
#########################################


def _save_kernel(mol,file_location,kernel_name,eigenvectors,output_extension):
    """
    This functions saves the eigenmodes of a kernel
    """

    output_extension = output_extension.lower().strip(".")

    if output_extension == "npy":
        try: os.mkdir(file_location + "rgmol//"+kernel_name)
        except: pass
        for eigenvector in range(len(eigenvectors)):
            file_name = "eigenvector_{}.npy".format(eigenvector)
            np.save(file_location+"rgmol//"+kernel_name+"//"+file_name,eigenvectors[eigenvector])



    else:
        with zf.ZipFile(file_location + "rgmol//cubes.zip","w",compression=zf.ZIP_DEFLATED) as rgmol_zip:

            try: rgmol_zip.write(kernel_name)
            except: pass

            for eigenvector in range(len(eigenvectors)):
                file_name = "eigenvector_{}.".format(eigenvector)
                temp_file_name = file_location + "temp//" + file_name
                if output_extension == "cube":
                    mol.write_cube(eigenvectors[eigenvector], temp_file_name+"cube")
                    rgmol_zip.write(temp_file_name+"cube",arcname = kernel_name + "//" + file_name+"cube")
                    os.remove(temp_file_name+"cube")
                elif output_extension == "csv" or output_extension == "txt":
                    mol.write_txt(eigenvectors[eigenvector], temp_file_name+"txt")
                    rgmol_zip.write(temp_file_name+"txt",arcname = kernel_name + "//" + file_name+"txt")
                    os.remove(temp_file_name+"txt")




def save(self,output_extension="npy"):
    """
    save(output_extension="npy")

    This function saves the eignemodes of the already computed kernels in a folder called rgmol.
    The rgmol folder is located in the same folder as the input file used for the molecule.
    By default the extension used is npy as it is the faster method.

    Parameters
    ----------
        output_extension : str, optional
            The output extension of the cube files. By default npy. The other extension available are txt and cube but are NOT recommended

    Returns
    -------
        None
            The files are written in the rgmol folder

    """

    file_location = _get_file_location(self.file)

    try: os.mkdir(file_location + "rgmol")
    except: pass
    try: os.mkdir(file_location + "temp")
    except: pass

    print("############################")
    print("# Writing the eigenvectors #")
    print("############################")
    time_before_writing = time.time()

    if "linear_response_eigenvalues" in self.properties:
        linear_response_eigenvalues = self.properties["linear_response_eigenvalues"]
        linear_response_eigenvectors = self.properties["linear_response_eigenvectors"]
        contribution_linear_response_eigenvectors = self.properties["contribution_linear_response_eigenvectors"]

        np.savetxt(file_location+"rgmol//linear_response_eigenvalues.txt",linear_response_eigenvalues,comments="#",header="Linear Response Eigenvalues")
        np.savetxt(file_location+"rgmol//contribution_linear_response.txt",contribution_linear_response_eigenvectors,comments="#",header="Contribution of transition densities on eigenmodes")
        _save_kernel(self,file_location,"linear_response_function",linear_response_eigenvectors,output_extension)


    if "softness_kernel_eigenvalues" in self.properties:
        softness_kernel_eigenvalues = self.properties["softness_kernel_eigenvalues"]
        softness_kernel_eigenvectors = self.properties["softness_kernel_eigenvectors"]
        contribution_softness_kernel_eigenvectors = self.properties["contribution_softness_kernel_eigenvectors"]

        np.savetxt(file_location+"rgmol//softness_kernel_eigenvalues.txt",softness_kernel_eigenvalues,comments="#",header="Softness Kernel Eigenvalues")
        np.savetxt(file_location+"rgmol//contribution_softness_kernel.txt",contribution_softness_kernel_eigenvectors,comments="#",header="Contribution of transition densities on eigenmodes")
        _save_kernel(self,file_location,"softness_kernel",softness_kernel_eigenvectors,output_extension)


    voxel_origin = self.properties["voxel_origin"]
    voxel_matrix = self.properties["voxel_matrix"]
    grid_points = self.properties["grid_points"]
    _write_voxel(file_location+"rgmol//voxel_parameters.txt",voxel_matrix,voxel_origin,grid_points)

    os.rmdir(file_location + "temp")

    print("#####################################")
    print("# Finished Writing the eigenvectors #")
    print("# in {:3.3f} #".format(time.time()-time_before_writing))
    print("#####################################")



def read(self):
    """
    read()

    This function reads the files located in the rgmol folder where the molecule is saved.

    Parameters
    ----------
        None
            All the parameters needed are already inside the molecule

    Returns
    -------
        None
            The properties will be put inside molecule.properties

    """

    file_location = _get_file_location(self.file)

    try: os.mkdir(file_location + "temp")
    except: pass
    listdir = os.listdir(file_location)
    if not "rgmol" in listdir:
        raise TypeError("No rgmol folder were found in the location where the input file of the molecule is.")

    listdir_rgmol = os.listdir(file_location + "rgmol")

    if "voxel_parameters.txt" in listdir_rgmol:
        voxel_matrix,voxel_origin,grid_points = _read_voxel(file_location+"rgmol//voxel_parameters.txt")
        self.properties["voxel_matrix"] = voxel_matrix
        self.properties["voxel_origin"] = voxel_origin
        self.properties["grid_points"] = grid_points
    else: raise ValueError("Voxel parameters not found")


    if "linear_response_function" in listdir_rgmol:
        print("#############################")
        print("# Extracting the eigenmodes #")
        print("#############################")
        time_before_extract = time.time()

        linear_response_eigenvectors = []

        listdir = os.listdir(file_location+"rgmol//linear_response_function")
        listdir_int = [int(files.split(".")[0][12:]) for files in listdir]

        arr_sort = np.argsort(listdir_int)
        listdir_sorted = []
        for index in arr_sort:
            listdir_sorted.append(listdir[index])

        for file in listdir_sorted:
            linear_response_eigenvectors.append(np.load(file_location+"rgmol//linear_response_function//"+file))
        self.properties["linear_response_eigenvectors"] = linear_response_eigenvectors

        print("######################################")
        print("# Finished Extracting the eigenmodes #")
        print("# in {:3.3f} #".format(time.time()-time_before_extract))
        print("######################################")

    if "softness_kernel" in listdir_rgmol:
        print("#############################")
        print("# Extracting the eigenmodes #")
        print("#############################")
        time_before_extract = time.time()

        softness_kernel_eigenvectors = []

        listdir = os.listdir(file_location+"rgmol//softness_kernel")
        listdir_int = [int(files.split(".")[0][12:]) for files in listdir]

        arr_sort = np.argsort(listdir_int)
        listdir_sorted = []
        for index in arr_sort:
            listdir_sorted.append(listdir[index])

        for file in listdir_sorted:
            softness_kernel_eigenvectors.append(np.load(file_location+"rgmol//softness_kernel//"+file))
        self.properties["softness_kernel_eigenvectors"] = softness_kernel_eigenvectors

        print("######################################")
        print("# Finished Extracting the eigenmodes #")
        print("# in {:3.3f} #".format(time.time()-time_before_extract))
        print("######################################")

    if "cubes.zip" in listdir_rgmol:
        print("#############################")
        print("# Extracting the eigenmodes #")
        print("#############################")
        time_before_extract = time.time()

        with zf.ZipFile(file_location+"//rgmol//cubes.zip",'r') as zip_folder:
            try:
                os.mkdir(file_location+"temp")
            except:
                pass

            zip_folder.extractall(path=file_location+"temp")

        linear_reponse_eigenvectors = []
        softness_kernel_eigenvectors = []

        for kernel_name in os.listdir(file_location+"temp"):
            for eigenvec in os.listdir(file_location+"temp//"+kernel_name):
                mol_temp = rgmol.extract_cube.extract(file_location+"temp//"+kernel_name+"//"+eigenvec)

                if kernel_name == "linear_response":
                    linear_response_eigenvectors.append(mol_temp.properties["cube"])
                elif kernel_name == "softness_kernel":
                    softness_kernel_eigenvectors.append(mol_temp.properties["cube"])

                os.remove(file_location+"temp//"+kernel_name+"//"+eigenvec)
            os.remove(file_location+"temp//"+kernel_name)
        os.remove(file_location+"temp")

        if len(linear_response_eigenvectors) != 0:
            self.properties["linear_response_eigenvectors"] = linear_response_eigenvectors
        if len(softness_kernel_eigenvectors) != 0:
            self.properties["softness_kernel_eigenvectors"] = softness_kernel_eigenvectors

        print("######################################")
        print("# Finished Extracting the eigenmodes #")
        print("# in {:3.3f} #".format(time.time()-time_before_extract))
        print("######################################")

    if "linear_response_eigenvalues.txt" in listdir_rgmol:
        linear_response_eigenvalues = np.loadtxt(file_location + "rgmol//linear_response_eigenvalues.txt")
        contribution_linear_response = np.loadtxt(file_location + "rgmol//contribution_linear_response.txt")

        self.properties["linear_response_eigenvalues"] = linear_response_eigenvalues
        self.properties["contribution_linear_response_eigenvectors"] = contribution_linear_response

    if "softness_kernel_eigenvalues.txt" in listdir_rgmol:
        softness_kernel_eigenvalues = np.loadtxt(file_location + "rgmol//softness_kernel_eigenvalues.txt")
        contribution_softness_kernel = np.loadtxt(file_location + "rgmol//contribution_softness_kernel.txt")

        self.properties["softness_kernel_eigenvalues"] = softness_kernel_eigenvalues
        self.properties["contribution_softness_kernel_eigenvectors"] = contribution_softness_kernel


molecule.save = save
molecule.read = read